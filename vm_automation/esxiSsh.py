# Created by Aaron Soto (@_surefire_)
# in collaboration with Brendan Watters (@tychos_moose)
# released under the BSD license
# v0.1 (2017-June-25)

# TODO: Test on ESXi 6.0 and 5.5 (only tested with ESXi 6.5)
# TODO: Confirm that snapshots work
# TODO: Determine whether VMX hardware changes between snapshots are copied over
# TODO: Allow cloining from a previous source snapshot to a new destination machine

import esxiVm
import json
import pexpect
from pyVmomi import vim


class esxiSsh(esxiVm.esxiServer):

    @staticmethod
    def createFromConfig(configDictionary, logFile="defaultLogfile.log"):
        """
        IN MOST USE CASES, I JUST EXPECT A JSON FILE, SO I MADE AN OPTIONAL
        CONSTRUCTOR THAT TAKES A DICTIONARY GENERATED BY A JSON FILE
        """
        try:
            hostname = configDictionary['HYPERVISOR_HOST']
            username = configDictionary['HYPERVISOR_USERNAME']
            password = configDictionary['HYPERVISOR_PASSWORD']
            port = configDictionary['HYPERVISOR_LISTENING_PORT']
        except:
            return None
        return esxiSsh(hostname, username, password, port, logFile)

    @staticmethod
    def createFromFile(configFile, logFile="defaultLogfile.log"):
        """
        IN MOST USE CASES, I JUST EXPECT A JSON FILE, SO I MADE AN OPTIONAL
        CONSTRUCTOR THAT TAK
        """
        try:
            fileObj = open(configFile, 'r')
            configStr = fileObj.read()
            fileObj.close()
        except:
            return None
        try:
            hypervisorDic = json.loads(configStr)
        except:
            return None
        return esxiSsh.createFromConfig(hypervisorDic, logFile)

    def __copyOvfTool(self):
        # TODO: Detect if this version of ovftool is already present on remote server, then return true

        ovfToolsPath = './ovftool-4.2.0-4586971.tgz'
        ovfToolsURL = 'https://my.vmware.com/group/vmware/details?downloadGroup=OVFTOOL420&productId=491'
        try:
            f = open(ovfToolsPath,"rb");
            f.close()
        except IOError:
            self.logMsg("FATAL ERROR: VMware 'ovftool' is required for server-to-server cloning.  Download it from VMware at:")
            self.logMsg("   " + ovfToolsURL)
            self.logMsg("and place it in ovfToolsPath: " + ovfToolsPath)
            return False

        session = pexpect.spawn('scp -o ConnectTimeout=5 ' + ovfToolsPath + ' ' + \
                                 self.username + '@' + self.hostname + ":/tmp/ovftool.tgz")
        i = session.expect(['Are you sure you want to continue connecting (yes/no)?', 'Password:', 'Connection refused', 'Connection timed out'])

        if i == 0:
            # Are you sure you want to continue connecting (yes/no)?
            session.sendline('yes')
            session.expect('Password:')
            session.sendline(self.password)
        if i == 1:
            # Password:
            session.sendline(self.password)
        if i == 2:
            self.logMsg("Connection refused.  Confirm that SSH is enabled on the ESXi server")
            return False
            # Connection refused
        if i == 3:
            self.logMsg("Connection refused.  Confirm the IP address and that SSH is permitted on host.")
            return False
            # Connection timed out

        session.expect('100%')
        return True

    def cloneToServer(self, srcVm, destServer, destDatastore, destVm, timeout=60*30):
        # Copying between servers takes a while, so the default timeout is 30 minutes.
        if type(srcVm) != str or type(destVm) != str:
            self.logMsg("Source and destination VMs must be the VM names as strings.")
            return False
        elif type(destDatastore) != str:
            self.logMsg("Destination datastore must be a string.")
            return False
        elif type(destServer) != str:
            self.logMsg("Destination datastore must be the IP address as a string.")
            return False

        path, srcVmdk = self.__findVmdkPath(srcVm)

        if path is None or srcVmdk is None:
            self.logMsg("Unabled to find VM to clone.")
            return False

        session = self.__loginToEsx()

        # Configure source server firewall to allow outbound SSH and HTTP
        self.__toggleFirewallRules(session, enabled=True)

        # Deploy OVF Tool on source server
        if self.__deployOvfTool(session) is False:
            return False

        srcServer = self.username + ":" + self.password + "@" + self.hostname
        session.sendline('/tmp/ovftool/ovftool -dm=thin -ds=' + destDatastore \
                         + ' --name=' + destVm + ' vi://' + srcServer + '/' + srcVm \
                         + ' vi://' + destServer)
        # TODO: Fill in the following for success, timeout/refused, and name already exists
        i = session.expect(['Completed successfully','Error: Internal error: Failed to connect to server','Error: Duplicate name','Invalid target datastore specified','No network mapping specified'],timeout=timeout)
        if i == 0:
            # Completed successfully
            return True
        elif i == 1:
            # Error: Internal error: Failed to connect to server
            #   (Note: This occurs when there's a timeout or connection refused.  No way to discern the difference.)
            self.logMsg("Unable to connect to destination server.  Connection timed out or refused.")
        elif i == 2:
            # Error: Duplicate name
            self.logMsg("VM name already exists on destination server")
        elif i == 3:
            # Invalid target datastore specified
            self.logMsg("Datastore name not found on destination server")
        elif i == 4:
            # No network mapping specified.
            self.logMsg("Destination server is missing the case-sensitive network name required by this VM.")
        return False

    def __deployOvfTool(self,session):
        # Clear any previous files/directories
        session.sendline('rm -rf /tmp/ovftool*')

        # SCP the OVF tool to the source server
        if self.__copyOvfTool() is False:
            return False

        # Deploy the OVF tool
        session.sendline('mkdir /tmp/ovftool')
        session.sendline('tar xf /tmp/ovftool.tgz -C /tmp/ovftool')

        # Confirm OVF tool deployed properly
        session.sendline('/tmp/ovftool/ovftool --version')
        session.expect('VMware ovftool', timeout=5)

    def __toggleFirewallRules(self, session, enabled=False):
        prompt = ':~]'
        session.expect(prompt)

        for service in ['sshClient','httpClient']:
            session.sendline('esxcli network firewall ruleset set -e ' + str(enabled).lower() + \
                             ' -r ' + service)
            session.expect(prompt)

    def clone(self, srcVm, destVm, thinProvision=True):
        # srcVm = string, name of source VM
        # destVm = string, name of destination VM
        #    Limitations:
        #         Source VM must exist on one datastore
        #         Source VM name must be unique
        #         esxiServer must not be a vCenter server
        #         VM cannot contain multiple disks

        if type(srcVm) != str or type(destVm) != str:
            self.logMsg("Source and destination VMs must be the VM names as strings.")
            return False

        path, srcVmdk = self.__findVmdkPath(srcVm)

        session = self.__loginToEsx()

        # Make destination directory
        session.sendline('cd ' + path)
        session.sendline('mkdir ' + destVm)
        session.sendline('ls ' + path + '/' + destVm)
        self.logMsg("Created destination path at: " + path + '/' + destVm)

        # Copy non-VMDK files from source VM to destination VM
        session.sendline('find "' + path + '/' + srcVm + '" -maxdepth 1 -type f | grep -v ".vmdk"' + \
                         ' | while read file; do cp "$file" "' + path + '/' + destVm + '"; done')
        self.logMsg("Copied all on vmdk files to: " + path + '/' + destVm)

        # Copy VMDK files from source VM to destination VM
        destVmdk = srcVmdk.split('/')[-1]
        if thinProvision:
            session.sendline('vmkfstools -i "' + path + '/' + srcVmdk + '" -d thin "' \
                             + path + '/' + destVm + '/' + destVmdk + '"')
        else:
            session.sendline('vmkfstools -i "' + path + '/' + srcVmdk + '" -d zeroedthick "' \
                             + path + '/' + destVm + '/' + destVmdk + '"')

        # Wait for the VMDK copying to complete, and check for errors
        while True:
            i = session.expect(["Clone: 100% done.","Failed to clone disk","Failed to lock the file"], timeout=60*30)
            if i == 0:
                break
            elif i == 1:
                try:
                    session.expect("The file already exists", timeout=1)
                    self.logMsg("The VMDK already exists.  Pick a different destination VM name, or clean up your datastore first.")
                    return False
                except pexpect.TIMEOUT:
                    self.logMsg("An unknown error occured copying the VMDK.  Here, have a shell:")
                    session.interact()
            elif i == 2:
                self.logMsg("Unable to lock the VMDK file.  The VM must be powered off.")
                return False
        self.logMsg("Copied vmdk files to: " + path + '/' + destVm)

        # One last thing, register the new VM in the ESXi inventory
        session.sendline('vim-cmd solo/registervm ' + path + '/' + destVm + '/' + srcVm + '.vmx ' \
                         + destVm)
        try:
            i = session.expect(['^[0-9]+$'], timeout=30)
            if i == 0:
                self.logMsg(str(session.before))
                self.logMsg(str(session.after))
            else:
                self.logMsg("???")
            session.sendline("exit")
            session.expect(["Connection to .* closed."], timeout=10)
            self.logMsg("Registered " + destVm)
            return True
        except pexpect.TIMEOUT:
            self.logMsg("Failed to registered " + destVm + ". TIMEOUT")
            return False

    def __loginToEsx(self):
        session = pexpect.spawn('ssh -o ConnectTimeout=5 ' + self.username + '@' + self.hostname)
        i = session.expect(['Are you sure you want to continue connecting (yes/no)?', 'Password:', 'Connection refused', 'Connection timed out'])
        if i == 0:
            # Are you sure you want to continue connecting (yes/no)?
            session.sendline('yes')
            session.expect('Password:')
            session.sendline(self.password)
        if i == 1:
            # Password:
            session.sendline(self.password)
        if i == 2:
            self.logMsg("Connection refused.  Confirm that SSH is enabled on the ESXi server")
            # Connection refused
        if i == 3:
            self.logMsg("Connection refused.  Confirm the IP address and that SSH is permitted on hte ESXi firewall")
            # Connection timed out
        return session

    def __findVmdkPath(self, srcVm):
        # srcVm could be a name (str), a vmId (int), or a vm object (vmObject)
        # destVm must be a name (what about workstation?  where will I store the new VM?)
        #                        what about ESXi?  What datastore should I use?

        self.enumerateVms()

        if type(srcVm) == str:
            datastore, srcVmdk = self.__findVmdkByName(srcVm)

        if not datastore or not srcVmdk:
            self.logMsg("Source VMDK could not be located")
            return None, None

        path = self.__findDatastorePath(datastore)

        return path, srcVmdk

    def __findVmdkByName(self, srcVm):
        vmObject = None

        for vm in self.vmList:
            if vm.vmName == srcVm and vmObject == None:
                vmObject = vm.vmObject
            elif vm.vmName == srcVm:
                self.logMsg("Unable to identify source VM.  Multiple VMs have that name")
                return None, None

        if vmObject == None:
            self.logMsg("Unable to identify source VM.  No VM found with that name")
            return None, None

        if len(vmObject.config.datastoreUrl) > 1:
            self.logMsg("VM uses multiple datastores. Clone not supported.")
            return None, None

        src = None

        for device in vmObject.config.hardware.device:
           if str(type(device)) == "<class 'pyVmomi.VmomiSupport.vim.vm.device.VirtualDisk'>":
               if src == None:
                   src = device.backing.fileName
               else:
                   self.logMsg("VM has multiple disks. Clone not supported.")
                   return None, None

        (datastore, srcVmdk) = src.split(" ")
        datastore = datastore[1:-1]

        return datastore, srcVmdk

    def __findDatastorePath(self,datastoreName):
        content = self.connection.content
        objView = content.viewManager.CreateContainerView(content.rootFolder,
                                                          [vim.HostSystem],
                                                          True)
        view = objView.view
        objView.Destroy()

        if len(view) > 1:
            self.logMsg("Multiple ESXi hosts found.  You must connect to the ESXi server directly, not vCenter")
            return False

        datastores = view[0].configManager.storageSystem.fileSystemVolumeInfo.mountInfo

        for datastore in datastores:
            if datastore.volume.type == "VMFS" and datastore.volume.name == datastoreName:
                return datastore.mountInfo.path

##########
# Example usage:
##########

# REQUIRED: First, connect to the ESXi server with the source image
# myserver = esxiSsh("192.168.1.1", "root", "password", "443", "esxi-192-168-1-1.log")
# myserver.connect()

# Copy a VM locally within myserver
# myserver.clone("sourceVmName","destinationVmName")

# Copy a VM from myserver to 192.168.1.2
# myserver.cloneToServer("sourceVmName","root:password@192.168.1.2","destinationDatastore","destinationVmName")
